package day23

import (
	"aoc2021/intmath"
	"fmt"
	"math"
	"os"
	"strings"
)

type amphipod byte

type position struct{ x, y int }

func manhatten(v1, v2 position) int {
	return intmath.Distance(v1.x, v2.x) + intmath.Distance(v1.y, v2.y)
}

func isHome(pod amphipod, position position) bool {
	return desiredBoard[position] == pod
}

func isInRoom(p position) bool {
	return p.y > 0
}
func isInHallway(p position) bool {
	return p.y == 0
}

func isEqual(p1, p2 position) bool {
	return p1.x == p2.x && p1.y == p2.y
}

var roomA1 = position{2, 1}
var roomA2 = position{2, 2}
var roomB1 = position{4, 1}
var roomB2 = position{4, 2}
var roomC1 = position{6, 1}
var roomC2 = position{6, 2}
var roomD1 = position{8, 1}
var roomD2 = position{8, 2}

var hallwayPositions = []position{
	{0, 0},
	{1, 0},
	// {2, 0},
	{3, 0},
	// {4, 0},
	{5, 0},
	// {6, 0},
	{7, 0},
	// {8, 0},
	{9, 0},
	{10, 0},
}

var desiredBoard = board{
	roomA1: amphipod('A'),
	roomA2: amphipod('A'),
	roomB1: amphipod('B'),
	roomB2: amphipod('B'),
	roomC1: amphipod('C'),
	roomC2: amphipod('C'),
	roomD1: amphipod('D'),
	roomD2: amphipod('D'),
}

var targetRooms = map[amphipod][2]position{
	'A': {roomA1, roomA2},
	'B': {roomB1, roomB2},
	'C': {roomC1, roomC2},
	'D': {roomD1, roomD2},
}

func sign(a int) int {
	if a > 0 {
		return 1
	} else {
		return -1
	}
}

func (b board) isBlocker(pos position) bool {
	pod := b[pos]
	roomPositions := targetRooms[pod]
	return isEqual(roomPositions[0], pos) && b[roomPositions[1]] != pod

}

type board map[position]amphipod

func (b board) availableDestinations(pod amphipod, currentPosition position) []position {
	out := make([]position, 0, 10)

	if isHome(pod, currentPosition) && !b.isBlocker(currentPosition) {
		return out
	}

	if isInRoom(currentPosition) {
		for _, targetPosition := range hallwayPositions {
			if b.canPathTo(currentPosition, targetPosition) {
				out = append(out, targetPosition)
			}
		}
		return out
	}

	if isInHallway(currentPosition) && canEnterHome(b, pod) {
		roomPos := roomTargetForPod(b, pod)
		if b.canPathTo(currentPosition, roomPos) {
			out = append(out, roomPos)
		}
		return out
	}

	return []position{}

	// panic("Unknown state")
}

// func isInTargetRoom(pod amphipod, currentPosition position) bool {
// 	targetPositions := targetRooms[pod]
// 	return currentPosition == targetPositions[0] || currentPosition == targetPositions[1]
// }

func canEnterHome(b board, pod amphipod) bool {
	top, bottom := podHomePositions(pod)
	if !b.isOccupied(top) && !b.isOccupied(bottom) {
		return true
	}

	if b.isOccupied(top) {
		return false
	}

	if b.isOccupied(bottom) && b[bottom] == pod {
		return true
	}

	return false

	// panic("Unknown state")
}

func podHomePositions(pod amphipod) (position, position) {
	return targetRooms[pod][0], targetRooms[pod][1]
}

func roomTargetForPod(b board, pod amphipod) position {
	top, bottom := podHomePositions(pod)

	if b.isOccupied(bottom) {
		return top
	} else {
		return bottom
	}
}

func (b board) canPathTo(from, to position) bool {
	if b.isOccupied(to) {
		return false
	}

	path := createPath(from, to)
	for _, pos := range path {
		if b.isOccupied(pos) {
			return false
		}
	}

	return true
}

func createPath(from, to position) []position {
	if isEqual(from, to) {
		panic("Positions are equal")
	}

	current := from

	out := make([]position, 0, 10)
	xDir := sign(to.x - from.x)
	yDir := sign(to.y - from.y)

	var addXPath = func() {
		for current.x != to.x {
			current.x += xDir
			out = append(out, current)
		}
	}
	var addYPath = func() {
		for current.y != to.y {
			current.y += yDir
			out = append(out, current)
		}
	}

	if isInRoom(from) {
		addYPath()
		addXPath()
	} else {
		addXPath()
		addYPath()
	}

	return out
}

func (b board) isOccupied(pos position) bool {
	_, found := b[pos]
	return found
}

type game struct {
	state board
	score int
}

func (b board) isWon() bool {
	for pos, pod := range desiredBoard {
		if b[pos] != pod {
			return false
		}
	}

	return true
}

func cost(from, to position, pod amphipod) int {
	distance := manhatten(from, to)
	return map[amphipod]int{
		amphipod('A'): 1,
		amphipod('B'): 10,
		amphipod('C'): 100,
		amphipod('D'): 1000,
	}[pod] * distance
}

func (g game) applyMove(from, to position) game {
	pod := g.state[from]
	cost := cost(from, to, pod)
	out := game{score: g.score + cost, state: board{}}

	for k, v := range g.state {
		out.state[k] = v
	}

	delete(out.state, from)

	out.state[to] = pod

	return out
}

var printDebug bool = false

func (g game) playMoves(lowScore *int) {
	if g.state.isWon() {
		if g.score < *lowScore {
			*lowScore = g.score
			fmt.Println(g.score)
		}
		// *finishedGames = append(*finishedGames, g)
		return
	}

	if g.score > *lowScore {
		return // Optimization, we're never going to beat the highscore, abort
	}

	for pos, pod := range g.state {
		if !isHome(pod, pos) || g.state.isBlocker(pos) {
			movements := g.state.availableDestinations(pod, pos)
			for _, to := range movements {
				newGame := g.applyMove(pos, to)

				if printDebug {
					fmt.Print(newGame.state)
				}

				newGame.playMoves(lowScore)
			}
		}
	}
}

func (b board) String() string {
	lines := make([][]byte, 3)

	for i := 0; i < 3; i++ {
		lines[i] = []byte("............")
	}

	for position, pod := range b {
		lines[position.y][position.x] = byte(pod)
	}

	sb := strings.Builder{}

	for _, v := range lines {
		sb.Write(v)
		sb.WriteRune('\n')
	}

	sb.WriteRune('\n')

	return sb.String()
}

func parseBoard(s string) board {
	parseLine := func(lineString string, y int) board {
		justChars := strings.ReplaceAll(strings.Trim(lineString, " "), "#", "")
		return board{
			position{2, y}: amphipod(justChars[0]),
			position{4, y}: amphipod(justChars[1]),
			position{6, y}: amphipod(justChars[2]),
			position{8, y}: amphipod(justChars[3]),
		}
	}

	lines := strings.Split(s, "\n")
	topRoomContent := parseLine(lines[2], 1)
	bottomRoomContent := parseLine(lines[3], 2)

	for k, v := range bottomRoomContent {
		topRoomContent[k] = v
	}

	return topRoomContent
}

func lowestScore(games []game) int {
	out := games[0].score
	for i := 1; i < len(games); i++ {
		if games[i].score < out {
			out = games[i].score
		}
	}
	return out
}

func Solve() {
	bytes, err := os.ReadFile("./day23/input.txt")

	if err != nil {
		panic(err)
	}

	board := parseBoard(string(bytes))

	g := game{state: board}

	// allGames := []game{}

	fmt.Printf("Starting board:\n\n%v\n\n", g.state)

	var score int = math.MaxInt

	g.playMoves(&score)

	// score := lowestScore(allGames)

	fmt.Printf("Lowest score:%v\n", score)
}
